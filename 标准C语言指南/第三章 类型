1.  C99引入_Bool类型，至少一字节，包含头文件<stdbool.h>则可用bool代替_Bool，取值为true和false

2.  C99引入unsigned long long  至少为64位

3.  扩展类型，例如int128_t，为编译器自定义

4. C99开始支持变长数组，数组长度可以不是常量表达式，变长数组不能具有文件作用域（不能有静态或线程存储期），因为无法在程序启动时分配空间

5. <stddef.h>定义offsetof宏，返回结构成员在结构中的偏移
 


6. 弹性数组成员前面必须至少还有一个成员，且弹性数组成员只能是最后一个成员

7. 弹性数组成员的大小不计入结构体，但可能影响结构体的尾部填充从而影响结构体大小 P99

8. 含有弹性数组成员的结构不能是其他结构，联合或者数组的成员（可以用指针替换）

9. 结构体对象相互赋值时不会赋值弹性数组成员 



10. 匿名结构作为结构或者联合的成员，则其成员当作所属结构或者联合的成员，该成员的初始化必须采用大括号嵌套包围的形式
   struct t{struct{int a,int b};};    
   struct t t1={{1,2}}；
   其中a和b被当作t的成员  




11. 标准要求联合成员列表不能为空，不同的C实现扩展可能合法

12. 联合成员也可能有尾部填充从而影响大小
    union u{int i;char c[21]}  ;大小为24




13. #define NULL (void*)0 是空指针常量
    (int *)0   (void *)NULL  是对应类型的空指针，但不是常量




14. C11支持原子类型 
    _Atomic (type)   ;  
    _Atomic (int) a;

    头文件<stdatomic.h>定义了不同类型原子版本的宏




15. const volatile restrict 的作用本质都与缓存优化有关
    const表明对象是只读的，可以在一次访问之后将其缓存，加速之后的访问过程
    volatile指对象可能在程序的其他地方，或者其他程序中（硬件端口）发生改变，所以不能缓存，防止读到错误的值
    restrict约定对象的访问只能通过当前指针进行，访问渠道唯一，所以可以将其缓存，且之后的修改都是对缓存进行，访问结束后再写回内存



 