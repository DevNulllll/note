1.依赖于实现的行为：标准未规定，有利于提高在特定平台的运行效率

2.未定义行为：几种行为都有可能发生，实现者并没有规定实际发生的是哪一种，例如数组访问越界，可能写入不相关内存，也可能导致硬件错或异常

3.C++的两种实现方式：独立式和宿主式

4.基本类型：布尔  字符  整数  浮点  void 
  内置类型: 基本类型  指针  引用

5.不同类型字符指针不存在转换规则（char ,signed char ,unsigned char）

6.转换方向为 signed char  ->  char  -> unsigned char  可以成功，逆向转换依赖于实现

7.字符字面值常量  'a' , '\048' , '\x48' , u'\uXXXX' , U'\U0000XXXX'

8.整数字面值类型由 形式（进制），值，后缀共同决定（6.2.4.2）

9.void 只能作为其他复杂类型的一部分，不存在void 类型的对象

10.基本类型的不同实现形式，差异体现在：内存需求（大小），内存访问时间（总线宽度？），计算时间，等

11.值v能用类型T确切表达，则v转换为T类型的值是值保护的（value - preserving）

12.size_t 是依赖于实现的无符号整数类型，用于表示任意对象所占的字节数。ptrdiff_t表示指针相减的值

13.alignof()运算符返回对齐方式（长度），alignas()类型说明符指定对齐方式

14.声明的结构 ： 可选前缀（static virtual），可选后缀（const noexcept）,基本类型，声明符，可选的初始化器
  声明符由一个名字和可选的声明运算符组成（指针，引用，数组等）

15.标签的作用域从声明处开始到函数体结束（具有函数作用域）

16.没有初始化器，静态对象，全局变量，名字空间变量执行相应数据类型的列表{}初始化；非静态对象，局部变量，若没有默认构造函数，则不执行默认初始化

17.在auto语句中，{}初始化被推断为std::initializer<T>

18.在实际编程中，一条表达式做为左值或者右值使用，不可能两者都是

19.临时对象的生命周期由其用法决定：若临时对象绑定一个引用，则与引用的生命周期一致，否则，与它所处的完整表达式一致

20.不允许在类型别名前加修饰符 ，例如 using ch=char; using uch=unsigned ch;