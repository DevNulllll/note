1.从已有类构建新类：实现继承，接口继承(运行时多态)

2.类必须提前定义才能作为基类（不能只声明）

3.类型域的使用违反了模块化和数据封装的原则（基类实现包含了子类的信息）（20.3.1）

4.正确顺序  void f(int) const noexcept override;    

5.一个派生类只能对自身类型的对象访问其基类的保护成员（防止一个派生类破坏另一个派生类的数据）（20.5.1）

6.protected最好只用于成员函数（20.5.1.1）
